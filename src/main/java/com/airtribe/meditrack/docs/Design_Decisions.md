# Design Decisions for MediTrack Application

## Why Interfaces Were Used

Interfaces were implemented in this project to achieve abstraction, polymorphism, and to define contracts that classes must follow. The `Searchable` interface provides a standardized way for different entities (doctors, patients, appointments) to implement search functionality, ensuring consistency across the codebase. By defining `searchById()` and `searchByName()` methods in the interface, we create a contract that any searchable entity must fulfill, making the code more maintainable and extensible. The `Payable` interface allows different types of bills or payment entities to implement billing calculations in a uniform manner. This design follows the Interface Segregation Principle, where interfaces define specific behaviors rather than forcing classes to implement unnecessary methods. Using interfaces also enables polymorphism, allowing different implementations to be used interchangeably, which makes the code more flexible and testable. Additionally, interfaces support multiple inheritance in Java (since classes can implement multiple interfaces), providing more design flexibility than abstract classes.

## Why Enums Were Used

Enums were chosen for representing fixed sets of constants like `Specialization` and `AppointmentStatus` because they provide type safety, readability, and prevent invalid values. Unlike using String constants or integer codes, enums ensure compile-time checking, meaning the compiler will catch errors if an invalid value is used. For example, `Specialization.CARDIOLOGY` is much clearer and safer than using the string "CARDIOLOGY" which could have typos. Enums also provide better IDE support with autocomplete, making development faster and less error-prone. They can have methods, constructors, and fields, making them more powerful than simple constants. In this project, enums prevent invalid appointment statuses or specializations from being entered, reducing runtime errors. They also make the code self-documenting - seeing `AppointmentStatus.SCHEDULED` immediately conveys meaning without needing to check documentation. Enums are also more memory-efficient than creating multiple instances of classes for constants, and they support switch statements natively, making code more readable and maintainable.

## Why Singleton Pattern for IdGenerator

The IdGenerator class uses static methods rather than a traditional singleton pattern, but the concept is similar - ensuring a single source of ID generation across the entire application. This design prevents ID conflicts and ensures uniqueness by maintaining centralized counters. If multiple instances of IdGenerator existed, they could generate duplicate IDs, leading to data integrity issues. By using static AtomicLong counters, we ensure thread-safe ID generation that works correctly even in multi-threaded environments. The AtomicLong class prevents race conditions when multiple threads try to generate IDs simultaneously. This centralized approach also makes it easier to modify ID generation logic in the future (e.g., changing the format from "PAT0001" to "PAT-2024-0001") since changes only need to be made in one place. Additionally, static methods don't require object instantiation, making ID generation more efficient and preventing unnecessary object creation. This design follows the Single Responsibility Principle by dedicating the class solely to ID generation, and it ensures consistency across all services that need to generate unique identifiers.

## Why Generic DataStore<T>

The generic `DataStore<T>` class was implemented to provide a reusable, type-safe storage solution for different entity types. Instead of creating separate storage classes for each entity (PatientStore, DoctorStore, AppointmentStore), a single generic class handles storage for all types, following the DRY (Don't Repeat Yourself) principle. Generics provide compile-time type safety, ensuring that a `DataStore<Patient>` can only store Patient objects, preventing ClassCastException at runtime. This design reduces code duplication significantly - the same storage logic (add, findById, findAll, findByName) works for all entity types without modification. The generic approach also makes the code more maintainable; if we need to add new storage methods or optimize existing ones, we only need to modify one class. Additionally, generics provide better IDE support with autocomplete and type checking, making development faster and less error-prone. The DataStore uses reflection to access `getId()` and `getName()` methods, which works because all entities extend Person or have these methods, demonstrating polymorphism. This design pattern is commonly used in frameworks and libraries, making the code more professional and aligned with industry best practices. The generic DataStore also makes it easier to add new entity types in the future without creating new storage infrastructure.

