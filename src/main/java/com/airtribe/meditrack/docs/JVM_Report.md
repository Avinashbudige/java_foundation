Class Loader:
Bootstrap Loader: Responsible for loading core Java API classes found in the rt.jar file.
Extension Loader: Loads classes from the Java Extensions directory (e.g., lib/ext).
Application Loader: Loads classes from the application's classpath.

Runtime Data Areas:
Heap: Storage for all objects and their data. Shared by all threads in the Java application.
Stack: Stores the state of method invocations (method call stack).
Method Area: Stores class structure (metadata), fields, methods data for all classes.
Program Counter (PC) Register: Holds the address of the JVM instruction currently being executed.
Native Method Stack: Supports native methods written in languages like C/C++.

Execution Engine:
It is the component of the JVM that executes the bytecode generated by the Java compiler.
It consists of an interpreter and a Just-In-Time compiler (JIT).

Interpreter vs JIT:
Interpreter: Reads Java bytecode instructions, interprets them, and executes them one at a time.
JIT Compiler: Instead of interpreting bytecodes one by one, the JIT compiler compiles chunks of bytecode into native machine code for maximum performance. After the code is compiled to machine code, it runs much faster.

Write Once Run Anywhere (Bytecode + JVM)
Bytecode: Java source code is compiled into an intermediate form known as bytecode. This bytecode is platform-independent, meaning it doesn't have to change across different operating systems.

Java Virtual Machine (JVM): The JVM is platform-specific. Each operating system has its own JVM that understands and executes the bytecode. Because of this, the same Java application can run on any device equipped with a compatible JVM, regardless of the underlying operating system.